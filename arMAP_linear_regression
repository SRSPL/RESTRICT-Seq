# ======================================================================
# Filename: arMAP_linear_regression.R
# Description:
#   Implementation of the arCas9 Modeling for Activity Prediction (arMAP)
#   linear regression algorithm in R using lm().
#
# This script demonstrates the linear relationship between inducible
#   nuclear translocation (T) and editing efficiency (E), constrained to
#   pass through the origin (E_i% = a * T_i), reflecting negligible editing
#   in the arCas9 OFF-state.
# ======================================================================

# --- 1. Load Required Libraries ------------------------------------------------
# lm() is part of base R; no additional packages are required.

# --- 2. Simulate Input Data ----------------------------------------------------
# Translocation (T): Nuclear translocation rates (Ti) quantified from arCas9SPARK
# images, expressed as the fraction of cells exhibiting nuclear EGFP enrichment.
# Timepoints (e.g., 0, 1, 3, 6, 12, 24, 48, 72 hours) are collected.
# Here, we simulate translocation rates (ranging from 0 to 1, or 0% to 100%):
Translocation_T <- c(0.00, 0.20, 0.45, 0.70, 0.85, 0.95, 0.99, 1.00) 

# Editing efficiency (E): Percentage of EGFP+ cells or normalized MFI measured via flow cytometry.
# Values represent editing outcomes at 72 h post-induction, which is used as the calibration time point.
# For simulated data, we model a strong linear dependence between nuclear translocation (T)
# and editing efficiency (E), with minor random noise added to mimic experimental variability.
set.seed(42)  # For reproducibility

# Example experimental measurements
Editing_Efficiency_E <- c(0.00, 0.15, 0.40, 0.65, 0.82, 0.90, 0.95, 0.96)
# Simulated editing efficiency data proportional to translocation rate
Editing_Efficiency <- (Translocation_Rate * 80) + runif(length(Translocation_T), -2, 2)
# Ensure non-negative values
Editing_Efficiency[Editing_Efficiency_E < 0] <- 0

# Combine into a data frame
armap_data <- data.frame(Translocation_T, Editing_Efficiency_E)

# --- 3. Fit the Linear Model using lm() with Default Settings ---
# The linear model relates translocation (T) to editing (E).
# By default, lm() includes an intercept (b), fitting the model: E_i% = a*T_i + b.

armap_model_fit <- lm(Editing_Efficiency_E ~ Translocation_T, data = armap_data)

# Print the model summary
print(summary(armap_model_fit))

# --- 4. Extract the Slope (a) and Apply the arMAP Constraint ---
# The core arMAP algorithm relies on the simplified model E_i% = a*T_i, 
# where the intercept (b) is set to 0 because arCas9 editing is negligible in the OFF-state.
# The slope (a) is calculated using the 72h calibration point (E_72h / T_72h).

# Example calculation of the slope (a) based on the 72h measurement:
E_72h <- Editing_Efficiency_E[length(Editing_Efficiency_E)] # 0.96
T_72h <- Translocation_T[length(Translocation_T)] # 1.00

# Calculate the slope 'a' (the predicted editing activity constant).
a_slope <- E_72h / T_72h
cat("\nCalculated slope (a) (E_72h / T_72h) for arMAP prediction:", a_slope, "\n")

# --- 5. Predict Editing Efficiency for New Translocation Input -----------------
# To predict editing (E_i%) for earlier time points (T_i):
# Predicted_Editing <- a_slope * Translocation_T
Predicted_Editing_E <- a_slope * armap_data$Translocation_T

# Compare measured E vs predicted E
armap_results <- data.frame(
  Time_Point = seq_along(Translocation_T),
  Translocation_T = armap_data$Translocation_T,
  Measured_Editing_E = armap_data$Editing_Efficiency_E,
  Predicted_Editing_E = Predicted_Editing_E
)
print(armap_results)

# --- 6. End of Script ----------------------------------------------------------
# This script replicates arMAP implementation in R.
# ======================================================================
